###分析一些CWAC构建

这本书的作者发布了一些开源的类库，叫做CommonsWare Android 组件。这些组件在转化到Gradle的时候
遭遇到了令人关注的挑战，审视之下，这些类库已经有了许多存在的用户，其中一些仍旧使用的Eclipse,Ant,
或其他基于旧式项目结构的工具。因此，这些项目需要能够没有Gradle就能构建，但是仍旧需要能够发布成
artifact而能被Gradle使用。

在这节中，我们会分析它们其中的一些项目，来看看Gradle支持是如何实现的，特别是依赖方面。

####一个简单的CWAC项目:cwac-layouts

大部分的CWAC项目是相当简单的。除了相对较少的几个类之外，大部分的CWAC项目对于Android本身没有依赖。
它们相当支持Gradle，对于构建类库和发布一个Gradle兼容的artifact都有。

例如，在自定义视图中所讨论的cwac-layouts,它提供了一些视图，特别是镜像类。

cwac-layouts仓库有着两个项目：layouts和demo。layouts项目是针对类库本身的，er
demo展示了类库的使用。

当使用Eclipse，Ant以及相关工具构建的时候，layouts是一个Android类库，
而demo是通过它的project.properties文件进行依赖的。

      #This file is automatically generated by Android Tools
     #Do not modify this file-- YOUR CHANAGES WILL BE ERASED!
     #
     #This file must be checked in Version Control Systems.
     #
     #To customize properties used by the Ant build system edit
     #"ant.properties",and override values to adapt the script to your  
     #project structure
     #
     #To enable ProGuard to shrink and obfuscate  your code,uncomment this(avaiable properties:sdk.dir,user.home):
     #progound.config=${sdk.dir}/tools/proguard/proguard-android-project.txt

     # Project target
     target=android-17
     android.library.reference.1=../layouts

对于Gradle构建，demo和layouts变成了模块,在项目根目录下的settings.gradle文件的帮助下：

     include ‘layouts’,'demo'

demo模块依赖于layouts模块，因为它是跟随Eclipse/Ant构建。但是，它是以下两种方法的一种实现：

* 如果这是一个debug版本，它依赖于layouts模块，所以样例应用能使用正在开发模块。
* 如果这是一个release版本，它依赖于CommonsWare artifact 仓库

      apply plugin:'com.android.application'

      repositories{
        maven{
          url "https://s3.amazons.com/repo.commonsWare.com"
        }
      }

      denpendencies{
         debugCompile project('lauouts')
         releaseCompile 'com.commonsware.cwac:layouts:0.4+'
      }
      android{
        compileSdkVersion 17
        buildToolsVersion "19.1.0"

        sourceSets{
          main{
            minifest.src 'AndroidManifest.xml'
            java.srcDirs=['src']
            resources.srcDirs=['src']
            aidl.srcDirs=['src']
            renderscript.srcDirs=['src']
            res.srcDirs=['res']
            assets.srcDirs=['assets']
          }
          debug.setRoot('build-types/debug')
          release.setRoot('build-types/release')
        }
      }    

在所有其他方面，样例项目的build.gradle约束成使用旧式项目结构的实现。

类库的build.gradle文件就稍微复杂了：


          android{
            compileSdkVersion 17
            buildToolsVersion "19.1.0"
            sourceSets{
              main{
                mainfest.srcFile 'AndroidManifest.xml'
                java.srcDirs=['src']
                resources.srcDirs=['src']
                aidl.srcDirs=['src']
                renderscript.srcDirs=['src']
                res.srcDirs=['res']
                assets.sirDirs=['assets']
              }
              debug.setRoot('build-types/debug')
              release.setRoot('build-types/release')
            }
          }
          
          if(project.hasProperty('PUBLISH_GROUP_ID')){
               //from http://stackoverflow.com/a/1948146/115145
               android.libraryVariants.all{variant->
                   def name=variant.buildType.name
                   if
               (name.equals(com.android.builder.core.BuilderConstants.DEBUG)){
                    return;//Skip debug builds
               }    
               def task=project.tasks.create "jar${name.capitalize()})",
               task.dependsOn variant.javaCompile
               task.from variant.javaCompile.destionationDir
               task.baseName="cwac-${PUBLISH_ARITIFACT_ID}"
               task.version=PUBLISH_VERSION
               task.exclude('com/commonsware/cwac/**/BuildConfig.**')
          }
          
          apply plugin:'maven'
          
          uploadArchives{
              repositories.mavenDeployer{
                  repositories.mavenDeployer{
                    pom.groupId=PUBLISH_GROUP_ID
                    pom.artifactId=PUBLISH_ARTIFACT_ID
                    pom.version=PUBLISH_VERSION
                    
                    repository(url: LOCAL_REPO)
                  }
              }
          }
    
正如这章早前提到的，它使用了maven插件来实现uploadArchives的task。这会类库项目编译成一个AAR然后发布到到
开发机器的本地CWAC Maven仓库。独立开来的，作者也有着一个发布必要文件到Amazon S3持有的CommonsWare Maven
仓库。


常量指的是gradle.properties文件中的repositories.mavenDeployer闭包，会在下一章涵盖到。

类库的build.gradle文件也包含了自定义的Gradle代码，这个代码添加了一个如这章早前所示的jarRelase ask。这个task也使用了来自gradle.properties的像PUBLISH_VERSION和PUBLISH_ARTIFACT_ID这样的值。因此，当作者想要发布一个新版本类库的时候，步骤是：

1.修改gradle.properties中的PUBLISH_VERSION
2.运行gradle uoloadArchives 生成AAR并发布在本地
3.使用一个外部机制发布AAR到CommonsWare仓库
4.运行grale jarRelease 来生成项目的JAR版本
5.通过github仓库的releases部分发布JAR包

####CWAC之上的CWAC:cwac-presentation

CWAC-Presentation是一个有着CWAC依赖的项目。这在展示和外部演示支持讨论过，提供了PresentationHelper以及
相关的类不费力地制作支持外部展示的应用。


          
